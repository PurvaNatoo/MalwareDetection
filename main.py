import os, math
import argparse
from PIL import Image
from queue import Queue
from threading import Thread


"""
Start by getting the binary values as a list

""" 
def extractBinaries(fileName):


	binaryValues = []

	with open(fileName, 'rb') as fileObject:

		# read file byte by byte
		dataFiles = fileObject.read(1)

		while dataFiles != b'':
			binaryValues.append(ord(dataFiles))
			dataFiles = fileObject.read(1)

	return binaryValues

"""
We can use the binary values to create RGB image

"""
# def createRGBImage(fileName, width=None):

# 	i = 0
# 	rgbData = []

# 	# Read binary file
# 	binaryData = extractBinaries(fileName)

# 	# Create R,G,B pixels
# 	while (i + 3) < len(binaryData):
# 		R_value = binaryData[i]
# 		G_value = binaryData[i + 1]
# 		B_value = binaryData[i + 2]
# 		i += 3
# 		rgbData.append((R_value, G_value, B_value))

# 	fileSize = getImageSize(len(rgbData), width)
# 	saveImageFile(fileName, rgbData, fileSize, 'RGB')

"""
We can use the same binary values to create gray scaled images as well

"""
def grayedImageGen(fileName, width=None):


	grayedData = extractBinaries(fileName)
	fileSize = getImageSize(len(grayedData), width)
	saveImageFile(fileName, grayedData, fileSize, 'L')

"""
The saved file should have the same prefix as the opcode that was used to generate the file. 
"""
def saveImageFile(fileName, data, size, imageType):

	try:
		imageFile = Image.new(imageType, size)
		imageFile.putdata(data)

		# setup output filename
		dirname     = os.path.dirname(fileName)
		name, _     = os.path.splitext(fileName)
		name        = os.path.basename(name)
		imageName   = dirname + os.sep + imageType + os.sep + name + '_'+imageType+ '.png'
		os.makedirs(os.path.dirname(imageName), exist_ok=True)

		imageFile.save(imageName)
		print('The file', imageName, 'saved.')
	except Exception as error:
		print(error)

"""
Different opcode files have different sizes. 
We should create an image relatively equivalent to the size of the opcode
"""
def getImageSize(dataLength, width=None):

	if width is None:

		imageSize = dataLength

		if (imageSize < 10240):
			width = 32
		elif (10240 <= imageSize <= 10240 * 3):
			width = 64
		elif (10240 * 3 <= imageSize <= 10240 * 6):
			width = 128
		elif (10240 * 6 <= imageSize <= 10240 * 10):
			width = 256
		elif (10240 * 10 <= imageSize <= 10240 * 20):
			width = 384
		elif (10240 * 20 <= imageSize <= 10240 * 50):
			width = 512
		elif (10240 * 50 <= imageSize <= 10240 * 100):
			width = 768
		else:
			width = 1024

		height = int(imageSize / width) + 1

	else:
		width  = int(math.sqrt(dataLength)) + 1
		height = width

	return (width, height)


def run(fileQueue, width):

	while not fileQueue.empty():
		fileName = fileQueue.get()
		grayedImageGen(fileName, width)
		# createRGBImage(fileName, width)
		fileQueue.task_done()


def main(input_dir, width=None, thread_number=7):

	"""
	 Create a queue for all the files in the specified directory and run then start creating the images
	 
	""" 
	fileQueue = Queue()
	for root, directories, files in os.walk(input_dir):
		for fileName in files:
			file_path = os.path.join(root, fileName)
			fileQueue.put(file_path)

	# Start thread
	for index in range(thread_number):
		thread = Thread(target=run, args=(fileQueue, width))
		thread.daemon = True
		thread.start()
	fileQueue.join()


if __name__ == '__main__':

	parser = argparse.ArgumentParser(prog='main.py', description="Convert opcodes to image")
	parser.add_argument(dest='input_dir')

	args = parser.parse_args()

	main(args.input_dir, width=None)

